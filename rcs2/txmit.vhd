-- *******************************************************************
-- 
-- Owner:	Xilinx Inc.
-- File:  	txmit.vhd
--
-- Purpose: 	UART transmit description.  Interprets
--		processor read/write parallel bus cycles
--		and converts to output serial data.
--
-- Created:	VHDL code generated by Visual HDL 8-15-01
--
-- Revision 2.00 (Ning Chen): avoid latch
--  
-- *******************************************************************

  
library ieee;
use ieee.STD_LOGIC_1164.all;
use ieee.STD_LOGIC_ARITH.all;
use ieee.STD_LOGIC_MISC.all;
use ieee.STD_LOGIC_UNSIGNED.all;
 
-- use work.pkg_util.all;

entity txmit is
  port (
        mclkx16 : in STD_LOGIC;
        write 	: in STD_LOGIC;
        reset 	: in STD_LOGIC;
        sout 	: out STD_LOGIC;
        txrdy 	: out STD_LOGIC;
        data 	: in STD_LOGIC_VECTOR (7 downto 0)
        );
end txmit;
 

architecture behavior of txmit is

-- ********************** SIGNAL DECLARATIONS *************************
signal write1 : STD_LOGIC;  			-- Delayed write signals
signal write2 : STD_LOGIC;
signal txdone1 : STD_LOGIC;  			-- txdone delayed signal

-- Transmit shift register bits
signal thr : STD_LOGIC_VECTOR(7 downto 0 );  	-- Transmit hold register
signal tsr : STD_LOGIC_VECTOR(7 downto 0 );  	-- Transmit shift register, used for shifting out data to sout
signal tag1 : STD_LOGIC; 			-- Tag bits used for detecting, when the tsr is empty
signal tag2 : STD_LOGIC;
signal paritymode : STD_LOGIC := 'Z';
signal txparity : STD_LOGIC;  			-- Parity generation register

-- Transmit clock and other control signals
signal txclk : STD_LOGIC;			-- Transmit clock, i.e. baudrate clock = mclkx16 / 16
signal txdone : STD_LOGIC;  			-- Set to high, when shifting of byte is done
signal paritycycle : STD_LOGIC;  		-- Set to high, one cycle next to last shift cycle
signal txdatardy : STD_LOGIC;  			-- Set to high, when data is ready in transmit hold register
signal cnt : STD_LOGIC_VECTOR(2 downto 0 ); 	-- Counter used for generating the internal baud rate clock


begin
 
 	   -- *************************** SIGNAL DEFINITIONS ****************************
	  paritymode <= '1';
	  
	  --  Paritycycle = 1 on next to last cycle, this means when tsr[1] gets tag2
	  paritycycle <= tsr(1) and not((tag2 or tag1 or tsr(7) or tsr(6) or tsr(5) or
	    		tsr(4) or tsr(3) or tsr(2)));
	  
	  --  txdone = 1 when done shifting, this means when sout gets tag2
	  txdone <= not(tag2 or tag1 or tsr(7) or tsr(6) or tsr(5) or tsr(4) or tsr(3)
	    		or tsr(2) or tsr(1) or tsr(0));
	  
	  --  Ready for new data to be written, when no data is in transmit hold register
	  txrdy <= not(txdatardy);	
	  
	  
	  -- *************************** PROCESS DEFINITIONS ****************************
	  --  Latch data[7:0] into the transmit hold register at falling edge of write
	  process (write, data)
	  begin

	    if not((write) = '1' ) then
	      thr <= data;
		 else
		   thr <= data;
	    end if ;
	    
	  end process ;
 
 	  
	  --  Toggle txclk every 8 counts, which divides the clock by 16, to generate the baud clock
	  process (mclkx16, reset)
	  begin

	    if (reset) = '1'  then
	      txclk <= '0';
	      cnt <= "000";
	      
	    elsif (mclkx16'event and mclkx16 = '1' ) then
	    
	      if cnt = "000" then
		txclk <= not(txclk);
	      end if ;
	      
	      cnt <= ext(ext(cnt,32) + 1,abs(2-0)+1);
	    end if ;
	  end process ;
 
 
	  --  Shifting out data to sout
	  process (txclk, reset)
	  begin

	    if (reset) = '1'  then
	      tsr <= "00000000";   --  Reset transmit shift register
	      tag2 <= '0';         --  Reset tag bit
	      tag1 <= '0';         --  Reset tag bit
	      txparity <= '0';     --  Reset txparty bit
	      sout <= '1';         --  Idle -> set start bit high
	      
	    elsif (txclk'event and txclk = '1' ) then
	    
	      if (txdone) = '1'  and (txdatardy) = '1'  then
		tsr <= thr;        --  Load thr to shift register
		tag2 <= '1';       --  Set tag bits for detecting when shifting is done
		tag1 <= '1';       --  Set tag bits for detecting when shifting is done
		txparity <= paritymode;  --  Set parity mode -> 0 = even parity, 1 = odd parity
		sout <= '0';       --  Set start bit low
		
	      else
		tsr <= std_logic_vector(SHR(unsigned(tsr) , unsigned'("00000000000000000000000000000001"
		       )));        --  Send LSB first
		tsr(7) <= tag1;    --  Set tsr[7] = tag1
		tag1 <= tag2;      --  Set tag1 = tag2
		tag2 <= '0';       --  Set tag2 = 0
		txparity <= txparity xor tsr(0);  --  Generate parity
		
		--  Shift out data or parity bit or stop/idle bit.
		if (txdone) = '1'  then
		  sout <= '1';     --  Output stop/idle bit
		else
		
		  if (paritycycle) = '1'  then
		    sout <= txparity;  --  Output parity bit
		  else
		    sout <= tsr(0);--  Shift out data bit
		  end if ;
		  
		end if ;
	      end if ;
	    end if ;
	    
	  end process ;
 
 
	  process (mclkx16, reset)
	  begin

	    if (reset) = '1'  then
	      txdatardy <= '0';
	      write2 <= '1';
	      write1 <= '1';
	      txdone1 <= '1';
	      
	    elsif (mclkx16'event and mclkx16 = '1' ) then
	    
	      if (write1) = '1'  and (write2 = '0' ) then
		txdatardy <= '1';  --  Set txdatardy on rising edge of write
		
	      else
		if (txdone = '0' ) and (txdone1) = '1'  then
		  txdatardy <= '0';--  Falling edge of txdone indicated the thr is loaded in the tsr
		end if ;
	      end if ;
	      
	      --  Generate delayed versions of write and txdone signals for edge detection.
	      write2 <= write1;
	      write1 <= write;
	      txdone1 <= txdone;
	    end if ;
	    
	  end process ; 
 
end ;


